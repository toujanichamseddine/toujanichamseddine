The error you're seeing (sessionStorage is not defined) is likely caused by the fact that sessionStorage is not available in server-side rendering (SSR) or if you're running your Angular app in an environment where the window or sessionStorage API is not available, such as during testing or in a non-browser context.

To resolve this, you need to ensure that you're using sessionStorage only in the browser environment. Here's how you can fix the issue:

1. Check if sessionStorage is Available Before Using It
In Angular, you can check if sessionStorage is available by checking if window is defined. This will prevent errors in environments where sessionStorage is unavailable (such as server-side rendering or testing).

Modify auth.service.ts:
typescript
Copier
Modifier
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class AuthService {

  // Check if we are in the browser
  private isBrowser(): boolean {
    return typeof window !== 'undefined' && typeof window.sessionStorage !== 'undefined';
  }

  // Check if user is logged in by checking sessionStorage
  isLoggedIn(): boolean {
    if (this.isBrowser()) {
      return !!sessionStorage.getItem('user'); // Replace 'user' with the key you use in sessionStorage
    }
    return false;
  }

  // Add other methods that interact with sessionStorage, ensuring isBrowser() is checked
}
2. Modify auth.guard.ts to Safely Use sessionStorage
In the auth.guard.ts, when checking if a user is logged in, make sure that you are doing it in the browser context.

Modify auth.guard.ts:
typescript
Copier
Modifier
import { Injectable } from '@angular/core';
import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from '@angular/router';
import { Observable } from 'rxjs';
import { AuthService } from './auth.service';

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {

  constructor(private authService: AuthService, private router: Router) {}

  canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean {
    // Check if the user is logged in
    if (this.authService.isLoggedIn()) {
      return true;
    } else {
      // Redirect to login page if not logged in
      this.router.navigate(['/login']);
      return false;
    }
  }
}
3. Ensure You Are Using sessionStorage Correctly
Make sure that you're using sessionStorage only in the appropriate lifecycle hooks (e.g., after the browser is ready). Avoid using sessionStorage in constructors or other places where the context may not be fully initialized, like during Angularâ€™s server-side rendering phase.

4. Use Angular Universal (if SSR is involved)
If you're using Angular Universal for server-side rendering (SSR), you should ensure that the code using sessionStorage is only executed in the browser.

In this case, modify the usage of sessionStorage like this:

typescript
Copier
Modifier
// Check if we are running in the browser
const isBrowser = typeof window !== 'undefined';

if (isBrowser) {
  sessionStorage.setItem('user', JSON.stringify(userData)); // Example usage
}
This prevents errors in SSR environments where window and sessionStorage might not be defined.

Summary:
Check for browser environment: Before using sessionStorage, ensure you're in a browser environment using typeof window !== 'undefined'.

Handle SSR scenarios: If using Angular Universal or SSR, make sure sessionStorage is only used in the client-side context.

Let me know if you need more help with this!
